# Введение в программирование

## Домашнее задание 1. Hello World

1. Установите [JDK 17+](https://adoptium.net/temurin/releases/?version=17)
2. Скопируйте один из вариантов HelloWorld, рассмотренных на практике.
3. Откомпилируйте HelloWorld.java и получите HelloWorld.class.
4. Запустите HelloWorld и проверьте его работоспособность.
5. Создайте скрипт, компилирующий и запускающий HelloWorld из командной строки.

Модификации
* *RunMe*
    1. Скачайте исходный код ([RunMe.java](java/RunMe.java))
    1. Создайте скрипт, компилирующий и запускающий `RunMe` из командной строки
       с выданными вам аргументами командной строки
    1. Следуйте выведенной инструкции

Рекомендации по выполнению модификации
1. Проверьте версию Java:
    1. Запустите `javac --version` и проверьте, что версия
       находится в диапазоне 11..17.
    1. Запустите `java --version` и проверьте, что версия
       такая же как и у `javac`.
1. Скачайте [RunMe.java](java/RunMe.java)
2. Откомпилируйте `RunMe.java`:
    1. Запустите `javac RunMe.java`
    1. Убедитесь, что компиляция завершилась бе ошибок
    1. Проверьте, что появился `RunMe.class`
3. Запустите `RunMe`:
    1. Запустите `java RunMe [шесть] [слов] [пароля] [пришедшего] [на] [email]`
    1. При правильном исполнении вы должны получить ссылку
       Если получено сообщение об ошибке — исправьте её и запустите повторно
    1. Зайдите по полученной ссылке и убедитесь, что она правильная
4. Напишите и протестируйте скрипт:
    1. Напишите скрипт, включающий команды компиляции и запуска.
       Если вы не умеете писать скрипты, во воспользуйтесь одной из инструкций:
       [Windows](https://www.windowscentral.com/how-create-and-run-batch-file-windows-10),
       [Linux](https://linuxhint.com/write_simple_bash_script/),
       [macOS](https://www.hastac.org/blogs/joe-cutajar/2015/04/21/how-make-simple-bash-script-mac)
    1. Запустите и проверьте, что вы получили ту же ссылку, что и в предыдущем пункте
    1. Сдайте скрипт преподавателю
5. Вы можете получить больше плюсиков, модифицируя код `RunMe.java`

### [Решение]()

## Домашнее задание 2. Сумма чисел

1. Разработайте класс `Sum`, который при запуске из командной строки будет складывать переданные в качестве аргументов
   целые числа и выводить их сумму на консоль.
2. Примеры запуска программы:

       java Sum 1 2 3 

   Результат: 6

       java Sum 1 2 -3
   Результат: 0

       java Sum "1 2 3"
   Результат: 6

       java Sum "1 2" " 3"
   Результат: 6

       java Sum " "
   Результат: 0
   Аргументы могут содержать:
    * цифры;
    * знаки + и -;
    * произвольные [пробельные символы](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#isWhitespace(char)).
3. При выполнении задания можно считать, что для представления входных данных и промежуточных результатов достаточен тип
   int.
4. Перед выполнением задания ознакомьтесь с документацией к классам [String](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html)
   и [Integer](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html).
5. Для отладочного вывода используйте [System.err](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#err),
   тогда он будет игнорироваться проверяющей программой.

Модификации
* *BigIntegerHex* (38-39)
    * Входные данные помещаются в тип [BigInteger](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigInteger.html)
    * Шестнадцатеричные числа имеют префикс `0x`
    * Класс должен иметь имя `SumBigIntegerHex`
* *LongHex* (36-37)
    * Входные данные являются 64-битными целыми числами
    * Шестнадцатеричные числа имеют префикс `0x`
    * Класс должен иметь имя `SumLongHex`
* *Float* (34-35)
    * Входные данные являются 32-битными числами с формате с плавающей точкой
    * Класс должен иметь имя `SumFloat`
    * Числа разделяются [пробелами-разделителями](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#SPACE_SEPARATOR)
* *Long* (31-33)
    * Входные данные являются 64-битными целыми числами
    * Класс должен иметь имя `SumLong`

Для того, чтобы протестировать исходную программу:

1. Скачайте откомпилированные тесты ([SumTest.jar](artifacts/SumTest.jar))
1. Откомпилируйте `Sum.java`
1. Проверьте, что создался `Sum.class`
1. В каталоге, в котором находится `Sum.class` выполните команду
   ```
      java -jar <путь к SumTest.jar> Base
   ```
    * Например, если `SumTest.jar` находится в текущем каталоге, выполните команду
   ```
       java -jar SumTest.jar Base
   ```

Исходный код тестов:

* [SumTest.java](java/sum/SumTest.java)
* [SumTester.java](java/sum/SumTester.java)
* [Базовые классы](java/base/)

### [Решение]()

## Домашнее задание 3. Реверс

1. Разработайте класс `Reverse`, читающий числа из [стандартного ввода](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#in),
   и выводящий их на [стандартный вывод](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html#out)
   в обратном порядке.
2. В каждой строке входа содержится некоторое количество целых чисел (возможно ноль). Числа разделены пробелами. Каждое
   число помещается в тип int.
3. Порядок строк в выходе должен быть обратным по сравнению с порядком строк во входе. Порядок чисел в каждой строке
   также должен быть обратным к порядку чисел во входе.
4. Вход содержит не более 10<sup>6</sup> чисел и строк.
5. Для чтения чисел используйте класс [Scanner](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html).
6. Примеры работы программы:

| Ввод                                                                        | Вывод              |
|-----------------------------------------------------------------------------|--------------------|
| 1 2 <br/> 3                                                                 | 3 <br/> 2 1        |
| 3 <br/> 2 1                                                                 | 1 2 <br/> 3        |
| 1 <br/> <br/> 2 -3                                                          | -3 2 <br/> <br/> 1 |
| 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 <br/> 2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 | 4 3 <br/> 2 1      |

Модификации
* *Base*
    * Исходный код тестов:
      [ReverseTest.java](java/reverse/ReverseTest.java),
      [ReverseTester.java](java/reverse/ReverseTester.java)
    * Откомпилированные тесты: [ReverseTest.jar](artifacts/ReverseTest.jar)
        * Аргументы командной строки: модификации
* *Sum2* (38, 39)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чисел
      в прямоугольнике верхний левый угол матрицы — текущее число
    * Класс должен иметь имя `ReverseSum2`
* *Min2* (36, 37)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите минимум из чисел
      верхний левый угол матрицы — текущее число
    * Класс должен иметь имя `ReverseMin2`
* *Linear* (36-39)
    * Пусть _n_ – сумма числа чисел и строк во входе,
      тогда программе разрешается потратить не более 6_n_+O(1) памяти
* *Transpose* (34-35)
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      выведите ее в транспонированном виде
    * Класс должен иметь имя `ReverseTranspose`
* *Odd2* (31-33)
    * Выведите (в реверсивном порядке) только числа,
      у которых сумма номеров строки и столбца нечетная
    * Класс должен иметь имя `ReverseOdd2`

### [Решение]()

## Домашнее задание 4. Статистика слов

1. Разработайте класс `WordStatInput`, подсчитывающий статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов (') и дефисов (*Unicode category [Punctuation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#DASH_PUNCTUATION),
   [Dash](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Character.html#DASH_PUNCTUATION)*). Для
   подсчета статистики слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для
   каждого слова должна быть выведена одна строка, содержащая слово и число его вхождений во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Примеры работы программы:

| Входной файл                                                                   | Выходной файл                                                                                                         |
|--------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| To be, or not to be, that is the question:                                     | to 2 <br/> be 2 <br/> or 1 <br/> not 1 <br/> that 1 <br/> is 1 <br/> the 1 <br/> question 1                           |
| Monday's child is fair of face. <br/> Tuesday's child is full of grace.        | monday's 1 <br/> child 2 <br/> is 2 <br/> fair 1 <br/> of 2 <br/> face 1 <br/> tuesday's 1 <br/> full 1 <br/> grace 1 |                                                                            
| Шалтай-Болтай <br/> Сидел на стене. <br/> Шалтай-Болтай <br/> Свалился во сне. | шалтай-болтай 2 <br/> сидел 1 <br/> на 1 <br/> стене 1 <br/> свалился 1 <br/> во 1 <br/> сне 1                        |

Модификации
* *Base*
    * Класс должен иметь имя `WordStatInput`
    * Исходный код тестов:
      [WordStatTest.java](java/wordStat/WordStatTest.java),
      [WordStatTester.java](java/wordStat/WordStatTester.java),
      [WordStatChecker.java](java/wordStat/WordStatChecker.java)
    * Откомпилированные тесты: [WordStatTest.jar](artifacts/WordStatTest.jar)
        * Аргументы командной строки: модификации
* *Count* (34, 35, 38, 39)
    * В выходном файле слова должны быть упорядочены по возрастанию числа
      вхождений, а при равном числе вхождений – по порядку первого вхождения
      во входном файле.
    * Класс должен иметь имя `WordStatCount`
* *Words* (31, 32, 33, 36, 37)
    * В выходном файле слова должны быть упорядочены в лексикографическом порядке
    * Класс должен иметь имя `WordStatWords`
* *Sort* (36-39)
    * Пусть _n_ – число слов во входном файле,
      тогда программа должна работать за O(_n_ log _n_).

### [Решение]()

## Домашнее задание 5. Свой сканер

1. Реализуйте свой аналог класса [Scanner](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html)
   на основе [Reader](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Reader.html).
2. Примените разработанный `Scanner` для решения задания «Реверс».
3. Примените разработанный `Scanner` для решения задания «Статистика слов».
4. Нужно использовать блочное чтение. Код, управляющий чтением, должен быть общим.
5. *Сложный вариант.* Код, выделяющий числа и слова, должен быть общим.
6. Обратите внимание на:
    * Обработку ошибок.
    * На слова/числа, пересекающие границы блоков, особенно — больше одного раза.

Модификации
* *Base*
    * Исходный код тестов: [FastReverseTest.java](java/reverse/FastReverseTest.java)
    * Откомпилированные тесты: [FastReverseTest.jar](artifacts/FastReverseTest.jar)
        * Аргументы командной строки: модификации
* *HexAbc2* (38-39)
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`
    * Десятеричные числа могут быть записаны буквами
      нулю соответствует буква `a`, единице – `b` и так далее
    * Выведите все числа, используя буквенный формат
    * Класс должен иметь имя `ReverseHexAbc2`
* *Linear* (38-39)
    * Пусть _n_ – сумма числа чисел и строк во входе,
      тогда программе разрешается потратить не более 5 _n_ +O(1) памяти
* *HexDec2* (36-37)
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`
    * Выведите все числа, используя формат шестнадцатеричных чисел
    * Класс должен иметь имя `ReverseHexDec2`
* *Hex2* (34-35)
    * Во вводе используются числа в шестнадцатеричной системе счисления
    * Класс должен иметь имя `ReverseHex2`
* *Abc2* (31-33)
    * Во вводе и выводе используются числа, записаные буквами:
      нулю соответствует буква `a`, единице – `b` и так далее
    * Класс должен иметь имя `ReverseAbc2`

### [Решение]()

## Домашнее задание 6. Статистика слов++

1. Разработайте класс `Wspp`, который будет подсчитывать статистику встречаемости слов во входном файле.
2. Словом называется непрерывная последовательность букв, апострофов и тире (*Unicode category Punctuation, Dash*). Для
   подсчета статистики, слова приводятся к нижнему регистру.
3. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для
   каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений
   этого слова среди всех слов во входном файле.
4. Имена входного и выходного файла задаются в качестве аргументов командной строки. Кодировка файлов: UTF-8.
5. Программа должна работать за линейное от размера входного файла время.
6. Для реализации программы используйте Collections Framework.
7. *Сложный вариант.* Реализуйте и примените класс `IntList`, компактно хранящий список целых чисел.
8. Примеры работы программы:

| Входной файл                                                                   | Выходной файл                                                                                                                                    |
|--------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| To be, or not to be, that is the question:                                     | to 2 1 5 <br/> be 2 2 6 <br/> or 1 3 <br/> not 1 4 <br/> that 1 7 <br/> is 1 8 <br/> the 1 9 <br/> question 1 10                                 |
| Monday's child is fair of face. <br/> Tuesday's child is full of grace.        | monday's 1 1 <br/> child 2 2 8 <br/> is 2 3 9 <br/> fair 1 4 <br/> of 2 5 11 <br/> face 1 6 <br/> tuesday's 1 7 <br/> full 1 10 <br/> grace 1 12 |                                                                            
| Шалтай-Болтай <br/> Сидел на стене. <br/> Шалтай-Болтай <br/> Свалился во сне. | шалтай-болтай 2 1 5 <br/> сидел 1 2 <br/> на 1 3 <br/> стене 1 4 <br/> свалился 1 6 <br/> во 1 7 <br/> сне 1 8                                   |

Модификации
* *Base*
    * Класс должен иметь имя `Wspp`
    * Исходный код тестов:
      [WsppTest.java](java/wspp/WsppTest.java),
      [WsppTester.java](java/wspp/WsppTester.java)
    * Откомпилированные тесты: [WsppTest.jar](artifacts/WsppTest.jar)
        * Аргументы командной строки: модификации
* *SortedSecondG* (38-39)
    * В выходном файле слова должны быть упорядочены в лексикографическом порядке
    * Вместо номеров вхождений во всем файле надо указывать
      только четныe вхождения в каждой строке.
    * Класс должен иметь имя `WsppSortedSecondG`
* *SecondG* (36-37)
    * Вместо номеров вхождений во всем файле надо указывать
      только четныe вхождения в каждой строке.
    * Класс должен иметь имя `WsppSecondG`
* *SortedPosition* (34-35)
    * В выходном файле слова должны быть упорядочены в лексикографическом порядке
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppSortedPosition`
* *Position* (31-33)
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер в строке>`
    * Класс должен иметь имя `WsppPosition`

### [Решение]()

## Домашнее задание 7. Разметка

1. Разработайте набор классов для текстовой разметки.
2. Класс `Paragraph` может содержать произвольное число других элементов разметки и текстовых элементов.
3. Класс `Text` – текстовый элемент.
4. Классы разметки `Emphasis`, `Strong`, `Strikeout` – выделение, сильное выделение и зачеркивание. Элементы разметки
   могут содержать произвольное число других элементов разметки и текстовых элементов.
5. Все классы должны реализовывать метод `toMarkdown`([StringBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/StringBuilder.html)),
   который должен генерировать [Markdown](https://ru.wikipedia.org/wiki/Markdown)-разметку по следующим правилам:
    * текстовые элементы выводятся как есть;
    * выделенный текст окружается символами '*';
    * сильно выделенный текст окружается символами '__';
    * зачеркнутый текст окружается символами '~'.
6. Следующий код должен успешно компилироваться:

       Paragraph paragraph = new Paragraph(List.of(
           new Strong(List.of(
               new Text("1"),
               new Strikeout(List.of(
                   new Text("2"),
                   new Emphasis(List.of(
                       new Text("3"),
                       new Text("4")
                   )),
                   new Text("5")
               )),
               new Text("6")
           ))
       ));

   Вызов `paragraph.toMarkdown(new StringBuilder())` должен заполнять переданный `StringBuilder` следующим содержимым:

   `__1~2*34*5~6__`
7. Разработанные классы должны находиться в пакете `markup`.

Модификации
* *Base*
    * Исходный код тестов:
        * [MarkupTester.java](java/markup/MarkupTester.java)
        * [MarkupTest.java](java/markup/MarkupTest.java)
        * Аргументы командной строки: модификации
* *Html* (34, 35)
    * Дополнительно реализуйте метод `toHtml`, генерирующий HTML-разметку:
        * выделеный текст окружается тегом `em`;
        * сильно выделеный текст окружается тегом `strong`;
        * зачеркнутый текст окружается тегом `s`.
* *HtmlList* (38, 39)
    * Сделайте модификацию *Html*
    * Добавьте поддержку:
        * Нумерованных списков (класс `OrderedList`, тег `ol`): последовательность элементов
        * Ненумерованных списков (класс `UnorderedList`, тег `ul`): последовательность элементов
        * Элементов списка (класс `ListItem`, тег `li`): последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
    * [Исходный код тестов](java/markup/MarkupListTest.java)
* *BBCode* (31-33)
    * Дополнительно реализуйте метод `toBBCode`, генерирующий [BBCode](https://en.wikipedia.org/wiki/BBCode)-разметку:
        * выделеный текст окружается тегом `i`;
        * сильно выделеный текст окружается тегом `b`;
        * зачеркнутый текст окружается тегом `s`.
* *BBCodeList* (36, 37)
    * Сделайте модификацию *BBCode*
    * Добавьте поддержку:
        * Нумерованных списков (класс `OrderedList`, тег `list=1`): последовательность элементов
        * Ненумерованных списков (класс `UnorderedList`, тег `list`): последовательность элементов
        * Элементов списка (класс `ListItem`, открывающий тег `*`): последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
    * [Исходный код тестов](java/markup/MarkupListTest.java)

### [Решение]()

## Домашнее задание 8. Git

Загрузите решения домашних заданий (в том числе, сданных) в ваш персональный git-репозиторий. Со следующей недели сдача
домашних заданий будет производиться только через репозитории.

Персональные репозитории имеют URL https://www.kgeorgiy.info/git-students/year2023/<USER>/prog-intro, где <USER> — имя
пользователя в PCMS (пароль так же используется из PCMS). Если у вас нет логина/пароля в PCMS, то cоберитесь группой и
обратитесь к Николаю Викторовичу.

Персональные репозитории являются клонами этого репозитория. В нём вы можете ознакомиться с правилами ведения
репозитория и рекомендациями по его настройке.

## Домашнее задание 9. Markdown to HTML

1. Разработайте конвертер из [Markdown](https://ru.wikipedia.org/wiki/Markdown)-разметки в [HTML](https://ru.wikipedia.org/wiki/HTML).
2. Конвертер должен поддерживать следующие возможности:
    1. Абзацы текста разделяются пустыми строками.
    2. Элементы строчной разметки: выделение (* или _), сильное выделение (** или __), зачеркивание (--), код (`)
    3. Заголовки (# * уровень заголовка)
3. Конвертер должен называться md2html.Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.
4. При выполнении этого ДЗ можно повторно использовать код ДЗ markup.
5. Конвертер может хранить исходные и сконвертированные данные в памяти, в том числе, одновременно.
6. Пример
    * Входной файл

             # Заголовок первого уровня

             ## Второго

             ### Третьего ## уровня

             #### Четвертого
             # Все еще четвертого

             Этот абзац текста,
             содержит две строки.

                 # Может показаться, что это заголовок.
             Но нет, это абзац начинающийся с `#`.

             #И это не заголовок.

             ###### Заголовки могут быть многострочными
             (и с пропуском заголовков предыдущих уровней)

             Мы все любим *выделять* текст _разными_ способами.
             **Сильное выделение**, используется гораздо реже,
             но __почему бы и нет__?
             Немного --зачеркивания-- еще ни кому не вредило.
             Код представляется элементом `code`.

             Обратите внимание, как экранируются специальные
             HTML-символы, такие как `<`, `>` и `&`.

             Знаете ли вы, что в Markdown, одиночные * и _
             не означают выделение?
             Они так же могут быть заэкранированы
             при помощи обратного слэша: \*.



             Лишние пустые строки должны игнорироваться.

             Любите ли вы *вложеные __выделения__* так,
             как __--люблю--__ их я?

    * Выходной файл

             <h1>Заголовок первого уровня</h1>
             <h2>Второго</h2>
             <h3>Третьего ## уровня</h3>
             <h4>Четвертого
             # Все еще четвертого</h4>
             <p>Этот абзац текста,
             содержит две строки.</p>
             <p>    # Может показаться, что это заголовок.
             Но нет, это абзац начинающийся с <code>#</code>.</p>
             <p>#И это не заголовок.</p>
             <h6>Заголовки могут быть многострочными
             (и с пропуском заголовков предыдущих уровней)</h6>
             <p>Мы все любим <em>выделять</em> текст <em>разными</em> способами.
             <strong>Сильное выделение</strong>, используется гораздо реже,
             но <strong>почему бы и нет</strong>?
             Немного <s>зачеркивания</s> еще ни кому не вредило.
             Код представляется элементом <code>code</code>.</p>
             <p>Обратите внимание, как экранируются специальные
             HTML-символы, такие как <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>.</p>
             <p>Знаете ли вы, что в Markdown, одиночные * и _
             не означают выделение?
             Они так же могут быть заэкранированы
             при помощи обратного слэша: *.</p>
             <p>Лишние пустые строки должны игнорироваться.</p>
             <p>Любите ли вы <em>вложеные <strong>выделения</strong></em> так,
             как <strong><s>люблю</s></strong> их я?</p>

    * Реальная разметка
# Заголовок первого уровня

## Второго

### Третьего ## уровня

#### Четвертого # Все еще четвертого

Этот абзац текста,
содержит две строки.

#&nbsp;Может показаться, что это заголовок. Но нет, это абзац начинающийся с #.

#И это не заголовок.

###### Заголовки могут быть многострочными (и с пропуском заголовков предыдущих уровней)

Мы все любим *выделять* текст _разными_ способами.
**Сильное выделение**, используется гораздо реже,
но __почему бы и нет__?
Немного ~~зачеркивания~~ еще ни кому не вредило.
Код представляется элементом `code`.

Обратите внимание, как экранируются специальные
HTML-символы, такие как <, > и &.

Знаете ли вы, что в Markdown, одиночные * и _
не означают выделение?
Они так же могут быть заэкранированы
при помощи обратного слэша: \*.

Лишние пустые строки должны игнорироваться.

Любите ли вы *вложеные __выделения__* так,
как __~~люблю~~__ их я?

Модификации
* *Базовая*
    * [Исходный код тестов](java/md2html/Md2HtmlTester.java)
    * [Откомпилированные тесты](artifacts/Md2HtmlTest.jar)
        * Аргументы командной строки: модификации
* *InsDel* (38, 39)
    * Добавьте поддержку
      `<<вставок>>`: `<ins>вставок</ins>` и
      `}}удалений{{`: `<del>удалений</del>`
* *Pre* (36, 37)
    * Добавьте поддержку
      \`\`\``кода __без__ форматирования`\`\`\`:
      `<pre>кода __без__ форматирования</pre>`
* *Quote* (34, 35)
    * Добавьте поддержку `''цитат''`: `<q>цитат</q>`
* *Var* (31-33)
    * Добавьте поддержку `%переменных%`: `<var>переменных</var>`

### [Решение]()

## Домашнее задание 10. Игра m,n,k

В этом домашнем задании вы можете пользоваться кодом, написанным на лекции. Он есть на сайте курса.

1. Реализуйте [игру m,n,k](https://en.wikipedia.org/wiki/M,n,k-game) (k в ряд на доске m×n).
2. Добавьте обработку ошибок ввода пользователя. В случае ошибочного хода пользователь должен иметь возможность сделать
   другой ход.
3. Добавьте обработку ошибок игроков. В случае ошибки игрок автоматически проигрывает.
4. *Простая версия.* Доска может производить обработку хода за O(*nmk*).
5. *Сложная версия.*
    * Доска должна производить обработку хода (проверку корректности, изменение состояния и определение результата) за
      O(*k*).
    * Предотвратите жульничество: у игрока не должно быть возможности достать `Board` из `Position`.
6. *Бонусная версия.* Реализуйте `Winner` — игрок, который выигрывает всегда, когда это возможно
   (против любого соперника).
7. Код должен находиться в пакете game.

Тесты не предусмотрены. Решение должно находиться в пакете `game`.

Модификации
* *Переговоры* (38-39)
    * У игрока должна быть возможность сдаться, если он не хочет продолжать игру.
    * Игрок может вместо своего хода предложить ничью.
      Если второй игрок принимает предложение, то игра заканчивается.
      В противном случае, игра продолжается и игрок делает ход.
      Повторное предложение ничьей на том же ходу считается ошибкой.
* *Турнир* (36-37)
    * Добавьте поддержку кругового турнира для нескольких участников.
    * В рамках кругового турнира каждый с каждым должен сыграть две партии,
      по одной каждым цветом.
    * Выведите таблицу очков по схеме:
        * 3 очка за победу;
        * 1 очко за ничью;
        * 0 очков за поражение.
* *Гекс* (36-39)
    * Добавьте поддержку ромбической доски для
      [игры Гекс](https://ru.wikipedia.org/wiki/Гекс)
      (с тремя направлениями линий).
    * В качестве примера, сделайте доску размером <em>11×11</em>.
* *Multiplayer* (34-35)
    * Добавьте поддержку значков `-` и `|`;
    * Добавьте возможность игры для 3 и 4 игроков.
* *Матчи* (31-33)
    * Добавьте поддержку матчей: последовательность игр до указанного числа побед.
    * Стороны в матче должны меняться каждую игру.

### [Решение]()

## Домашнее задание 11. Выражения

1. Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` для вычисления выражений с одной
   переменной в типе `int` (интерфейс `Expression`).
2. Классы должны позволять составлять выражения вида

       new Subtract(
           new Multiply(
               new Const(2),
               new Variable("x")
           ),
           new Const(3)
       ).evaluate(5)

   При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра
   методу `evaluate`. Таким образом, результатом вычисления приведенного примера должно стать число 7.
3. Метод `toString` должен выдавать запись выражения в полноскобочной форме. Например

       new Subtract(
           new Multiply(
               new Const(2),
               new Variable("x")
           ),
           new Const(3)
       ).toString()

   должен выдавать ((2 * x) - 3).
4. *Сложный вариант.* Метод `toMiniString` (интерфейс `ToMiniString`) должен выдавать выражение с минимальным числом
   скобок. Например

       new Subtract(
           new Multiply(
               new Const(2),
               new Variable("x")
           ),
           new Const(3)
       ).toMiniString()

   должен выдавать 2 * x - 3.
5. Реализуйте метод `equals`, проверяющий, что два выражения совпадают. Например,

       new Multiply(new Const(2), new Variable("x"))
           .equals(new Multiply(new Const(2), new Variable("x")))

   должно выдавать `true`, а

       new Multiply(new Const(2), new Variable("x"))
           .equals(new Multiply(new Variable("x"), new Const(2)))

   должно выдавать `false`.
6. Для тестирования программы должен быть создан класс `Main`, который вычисляет значение выражения x<sup>2</sup>−2x+1,
   для x, заданного в командной строке.
7. При выполнении задания следует обратить внимание на:
    * Выделение общего интерфейса создаваемых классов.
    * Выделение абстрактного базового класса для бинарных операций.

Модификации
* *Base*
    * Реализуйте интерфейс [Expression](java/expression/Expression.java)
    * [Исходный код тестов](java/expression/ExpressionTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
* *Triple* (31-39)
    * Дополнительно реализуйте поддержку выражений с тремя переменными: `x`, `y` и `z`.
    * Интерфейс [TripleExpression](java/expression/TripleExpression.java).
* *BigInteger* (36-37)
    * Дополнительно реализуйте вычисления в типе `BigInteger`.
    * Интерфейс [BigIntegerExpression](java/expression/BigIntegerExpression.java).
* *BigDecimal* (38-39)
    * Дополнительно реализуйте вычисления в типе `BigDecimal` .
    * Интерфейс [BigDecimalExpression](java/expression/BigDecimalExpression.java).

### [Решение]()

## Домашнее задание 12. Разбор выражений

1. Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида
   x * (x - 2)*x + 1
2. В записи выражения могут встречаться:
    * бинарные операции: умножение *, деление /, сложение + и вычитание -;
    * унарный минус -;
    * переменные x, y и z;
    * целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
    * круглые скобки для явного обозначения приоритета операций;
    * произвольное число пробельных символов в любом месте, не влияющем на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант).
3. Приоритет операций, начиная с наивысшего
    * унарный минус;
    * умножение и деление;
    * сложение и вычитание.
4. Разбор выражений рекомендуется производить [методом рекурсивного спуска](https://ru.wikibooks.org/wiki/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE_%D1%81%D0%BF%D1%83%D1%81%D0%BA%D0%B0).
    * Алгоритм должен работать за линейное время.
    * Лексический анализ (токенизация) не требуется.

Модификации
* *Base*
    * Класс `expression.parser.ExpressionParser` должен реализовывать интерфейс
      [Parser](java/expression/parser/Parser.java)
    * Результат разбора должен реализовывать интерфейс
      [TripleExpression](java/expression/TripleExpression.java)
    * [Исходный код тестов](java/expression/parser/ParserTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
* *Shifts* (38, 39)
    * Дополнительно реализуйте бинарные операции с минимальным приоритетом:
        * `<<` – сдвиг влево (`1 << 5 + 3` равно `1 << (5 + 3)` равно 256);
        * `>>` – сдвиг вправо (`1024 >> 5 + 3` равно `1024 >> (5 + 3)` равно 4);
        * `>>>` – арифметический сдвиг вправо (`-1024 >>> 5 + 3` равно `1024 >>> (5 + 3)` равно -4);
* *MinMax* (34-37)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
* *Zeroes* (31-33, 36-39)
    * Дополнительно реализуйте унарные операции
        * `l0` – число старших нулевых бит, `l0 123456` равно 15;
        * `t0` – число младших нулевых бит, `t0 123456` равно 6.

### [Решение]()

## Домашнее задание 13. Обработка ошибок

1. Добавьте в программу, вычисляющую выражения, обработку ошибок, в том числе:
    * ошибки разбора выражений;
    * ошибки вычисления выражений.
2. Для выражения 1000000*x*x*x*x*x/(x-1) вывод программы должен иметь следующий вид:

       x       f
       0       0
       1       division by zero
       2       32000000
       3       121500000
       4       341333333
       5       overflow
       6       overflow
       7       overflow
       8       overflow
       9       overflow
       10      overflow

   Результат `division by zero (overflow)` означает, что в процессе вычисления произошло деление на ноль (переполнение).
3. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
4. Человеко-читаемые сообщения об ошибках должны выводиться на консоль.
5. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

Модификации
* *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
      [Parser](java/expression/exceptions/Parser.java)
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
      `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
      [TripleExpression](java/expression/TripleExpression.java)
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
    * [Исходный код тестов](java/expression/exceptions/ExceptionsTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
* *PowLog* (36-39)
    * Дополнительно реализуйте бинарные операции (максимальный приоритет):
        * `**` – возведение в степень, `2 ** 3` равно 8;
        * `//` – логарифм, `10 // 2` равно 3.
* *Shifts* (38, 39)
    * Дополнительно реализуйте бинарные операции с минимальным приоритетом:
        * `<<` – сдвиг влево (`1 << 5 + 3` равно `1 << (5 + 3)` равно 256);
        * `>>` – сдвиг вправо (`1024 >> 5 + 3` равно `1024 >> (5 + 3)` равно 4);
        * `>>>` – арифметический сдвиг вправо (`-1024 >>> 5 + 3` равно `1024 >>> (5 + 3)` равно -4);
* *MinMax* (31-37)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
* *Abs* (36-39)
    * Дополнительно реализуйте унарную операцию
        * `abs` – модуль числа, `abs -5` равно 5.
* *Zeroes* (31-35)
    * Дополнительно реализуйте унарные операции
        * `l0` – число старших нулевых бит, `l0 123456` равно 15;
        * `t0` – число младших нулевых бит, `t0 123456` равно 6.

### [Решение]()